% LaTeX source for ``การเรียนรู้ของเครื่องสำหรับเคมีควอนตัม (Machine Learning for Quantum Chemistry)''
% Copyright (c) 2022 รังสิมันต์ เกษแก้ว (Rangsiman Ketkaew).

% License: Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)
% https://creativecommons.org/licenses/by-nc-nd/4.0/

\chapter{ลักษณะเฉพาะของอะตอมและโมเลกุล}
\label{ch:feature}

ลักษณะเฉพาะ (Feature) คือคุณลักษณะที่บ่งบอกความเฉพาะตัวของอะตอมหรือโมเลกุลนั้น ๆ ซึ่งอาจจะเรียกว่าเป็นคุณลักษณะแบบพิเศษ 
(Special Attributes) ก็ได้ นอกจากนี้เราสามารถตีความได้ว่า Feature นั้นจริง ๆ แล้วก็เปรียบเสมือกเป็นตัวแทนของสิ่งที่เราสนใจอีกด้วย 
ซึ่งในบริบททางเคมีนั้น เราจะเรียกสิ่งที่เป็นตัวแทนของโมเลกุลว่า Molecular Representation (จริง ๆ แล้ว Feature กับ Representation 
ก็ไม่ได้มีความหมายเหมือนกันเสียทีเดียว ขึ้นอยู่กับประเภทของข้อมูลที่ใช้เป็น Feature แต่ผู้เขียนจะใช้คำว่า Representation ในการอ้างถึง%
ลักษณะเฉพาะของระบบที่เรากำลังศึกษา (อะตอม, โมเลกุล, สารประกอบ) เพราะว่าให้ความหมายที่สื่อการเป็นตัวแทนของระบบที่เราสนใจได้ดีกว่า)
\cite{stepisnik2021}
\idxth{ลักษณะเฉพาะ}
\idxen{Representation}

คำถามที่ตามมาก็คือแล้ว Molecular Representation มีความสำคัญมากไหม และมีความสำคัญอย่างไร คำตอบก็คือมีความสำคัญและสำคัญมากด้วย 
อาจจะกล่าวได้ว่าสำคัญที่สุดเลยก็ว่าได้ เพราะ Representation ก็คืออินพุตที่เรานำมาใช้สร้างโมเดลนั่นเอง ดังนั้นมันจึงเป็นปัจจัยหลักที่กำหนด%
ประสิทธิภาพของโมเดลนั่นเอง 

เนื่องจากว่ามนุษย์สามารถแยกแยะโมเลกุลแต่ละตัวออกจากกันได้ แต่ว่าคอมพิวเตอร์ไม่สามารถทำได้ เพราะว่ามันเข้าใจข้อมูลที่เป็นแบบดิจิทัลในภาษา%
เครื่องจักรเท่านั้น (Machine Language) ดังนั้นเราจึงต้องมีการใช้ Representation เพื่ออธิบายโมเลกุลในรูปแบบของค่า Parameter ที่คอมพิวเตอร์%
สามารถเข้าใจได้ เช่น แปลงโมเลกุลเป็นเวกเตอร์ของตัวเลข สำหรับการอธิบายโมเลกุลแบบง่าย ๆ นั้นสามารถทำได้โดยใช้ Representation 
เพื่อมาอธิบายข้อมูลเชิงโครงสร้าง (Structural Properties) ซึ่งสามารถใช้ข้อมูลทางเคมีทั่วไปได้ ยกตัวอย่างเช่น รูปร่างของโมเลกุล, 
จำนวนหมู่ฟังก์ชัน, ชนิดของพันธะระหว่างอะตอมคาร์บอน, และจำนวนวงเบนซีน ซึ่งข้อมูลเหล่านี้เราสามารถคำนวณออกมาได้ง่าย ๆ ไม่มีความซับซ้อนอะไร 
แต่ปัญหาคือ Representation ที่เป็น Structure-based นั้นมีข้อมูลที่น้อยเกินไป จึงทำให้ไม่สามารถถูกนำมาใช้เป็นอินพุตสำหรับการสร้างโมเดล
เพื่อทำนายคุณสมบัติหรือพารามิเตอร์ทางเคมีที่ซับซ้อนหรือละเอียดกว่าได้ เช่น พลังงานพันธะ (Bond Energy), ค่าความถี่การสั่น (Vibration), 
ไดโพลโมเมนต์ (Dipole Moment), ฯลฯ นั่นก็เพราะว่าอินพุตของเราเป็น Representation ที่ไม่มีความสัมพันธ์กับเอาต์พุตที่เราต้องการทำนายโดยตรง

ดังนั้นถ้าหากเราต้องการที่จะทำนายเอาต์พุตที่มีความละเอียดอยู่ในระดับอะตอมหรือเชิงอิเล็กทรอนิกส์ เราควรจะใช้ Representation ที่อยู่ในระดับเดียวกัน 
และ Representationอินพุตเหล่านี้ควรจะต้องเก็บข้อมูลทางเคมีควอนตัมและฟิสิกส์ไว้ด้วย โดยการพัฒนา Representation โดยใช้องค์ความรู้ทางฟิสิกส์
(Physics-inspired Representation) ก็เป็นหนึ่งในหัวข้องานวิจัยที่กำลังมาแรงในขณะนี้ ข้อมูลทางฟิสิกส์ที่เราเพิ่มเข้าไปก็เปรียบเสมือนเป็น%
องค์ประกอบที่เพิ่มความถูกต้อง (Correction) ให้กับ Representation ให้มากขึ้น เราใส่ระบุความเป็นสมมาตร (Symmetricity) หรือคุณสมบัติ%
จากปรากฎการณ์ทางฟิสิกส์เชิงควอนตัมของโมเลกุลเข้าไปได้ เป็นต้น 

%--------------------------
\section{การแปลงข้อมูลเชิงโมเลกุล}
\idxth{การแปลงข้อมูลเชิงโมเลกุล}
%--------------------------

โมเลกุลประกอบไปด้วยอะตอมหลายอะตอมมารวมกัน เราจึงเปรียบเทียบโมเลกุลเป็นประโยคหรือข้อความและเปนียบเทียบอะตอมเป็นคำแต่ละคำได้
ดังที่บอกไปในข้างต้นว่าการทำให้คอมพิวเตอร์เข้าใจความเชื่อมโยงระหว่างอะตอมในโมเลกุลนั้นต้องมีการกำหนดหรือเลือกใช้ Representation ที่เหมาะสม
โดยคุณสมบัติของ Representation ที่ดีนั้นไม่เพียงแต่จะต้องไม่ขึ้นกับการเคลื่อนที่เชิงการหมุน (Rotational Motion) และ การเคลื่อนที่เชิงเส้นด้วย 
(Transitional Motion) เท่านั้น แต่ควรจะต้องมีความเรียบง่ายและไม่ซับซ้อนหรือยุ่งยากเกินไปในการคำนวณเพื่อสร้าง Machine Code 
จากพิกัดตำแหน่งคาร์ทีเชียน (Cartesian Coordinates)

%--------------------------
\section{ลักษณะเฉพาะเชิงโครงสร้างแบบทั่วไป}
\idxth{ลักษณะเฉพาะ!เชิงโครงสร้างแบบทั่วไป}
\idxen{Representation!Structural Representation}
%--------------------------

%--------------------------
\subsection{Internal Coordinates}
\idxen{Representation!Internal Coordinates}
%--------------------------

Internal Coordinates หรือเรียกอย่างว่า $Z$ Matrix (พิกัดภายในของโมเลกุล) เป็น Representation แบบที่ง่ายมาก 
อาจจะเรียกได้ว่าง่ายที่สุดเลยก็ว่าได้ ถูกใช้เป็น Descriptor มาอย่างยาวนาน โดยถูกใช้อย่างแพร่หลายในยุคแรก ๆ ของการเรียนรู้ของเครื่องสำหรับเคมี
Internal Coordinates สามารถอธิบายได้ทั้งโมเลกุล โดยองค์ประกอบของ Representation อันนี้มีความยาวพันธะระหว่างอะตอม (Bond Distance) 
มุมพันธะ (Bond Angle) และมุมบิดเบี้ยว (Dihedral Angle หรือ Torsion) ซึ่งจำนวนของอะตอมที่ถูกเลือกมาคำนวณ Internal Coordinates 
นั้นมักจะเป็นอะตอมที่เรียงกันอยู่หรืออยู่ใกล้กัน อย่างไรก็ตาม เราสามารถคำนวณหา Internal Coordinates ของโมเลกุลได้โดยพิจารณาอะตอมทุก ๆ คู่
หรือทุกความเป็นไปได้ทั้งหมดภายในโมเลกุล

%--------------------------
\subsection{Geometric Descriptors}
\idxth{ลักษณะเฉพาะ!เชิงเรขาคณิต}
\idxen{Representation!Geometric Descriptors}
%--------------------------

Geometric Descriptors (ลักษณะเฉพาะเชิงเรขาคณิต) เป็น Descriptor (จะเรียกแทนด้วย Representation ก็ได้) ที่อ้างอิงกับข้อมูล%
ตำแหน่งของอะตอมในโมเลกุล โดยมักจะเชื่อมโยงกับ Representation แบบที่เป็นสัญลักษณ์หรือ Symbolic เช่น SMILES ซึ่ง Geometric 
Descriptors ก็สามารถแบ่งออกเป็นได้หลาย Descriptor ซึ่งก็รวมไปถึง $Z$ Matrix, Coordination Number, Adjacency Matrix 
อย่างไรก็ตาม Representation ในกลุ่มนี้มักจะให้ผลการทำนายด้วย ML ไม่ค่อยดีนัก นั่นก็เพราะว่าความสามารถในการกักเก็บข้อมูลเชิงอิเล็กทรอนิกส์%
นั้นน้อยมากเมื่อเทียบกับ Representation ประเภทที่เป็นแบบเชิงอะตอม (Atom-wise Descriptor) และยังมีโมเลกุลบางประเภทที่ Geometric 
Descriptors ไม่สามารถนำไปใช้ได้ อย่างเช่นโมเลกุลไอโซเมอร์ เช่น cis/trans สเตอริโอไอโซเมอร์ ดังนั้น Representation ประเภทนี้จึงไม่%
เป็นที่นิยมในการนำมาเทรนโมเดลML ในงานวิจัยทางด้านเคมีควอนตัม\cite{keith2021,musil2021}

%--------------------------
\section{ลักษณะเฉพาะเชิงโครงสร้างสำหรับโมเลกุล}
\idxth{ลักษณะเฉพาะ!เชิงโครงสร้างสำหรับโมเลกุล}
\idxen{Representation!Molecular Representation}
%--------------------------

Representation ประเภทนี้จะเป็นการอธิบายสภาพแวดล้อม (Environment) ของอันตรกิริยาระหว่างอะตอมทุกอะตอมในโมเลกุล โดยมักจะอยู่ใน%
รูปของเมทริกซ์ เช่น เมทริกซ์ของส่วนกลับของระยะห่างระหว่างอะตอม (Inverse Distance Matrix) และเมทริกซ์คูลอมบ์ (Coulomb Matrix)

%--------------------------
\subsection{Inverse Distance Matrix}
\idxth{ลักษณะเฉพาะ!เมทริกซ์ของส่วนกลับของระยะห่างระหว่างอะตอม}
\idxen{Representation!Inverse Distance Matrix}
%--------------------------

Inverse Distance Matrix (เมทริกซ์ของส่วนกลับของระยะห่างระหว่างอะตอม) เป็น Representation Matrix แบบที่ง่ายที่สุดและมีความหมาย%
ทางเคมีที่ชัดเจน นั่นก็คือการใช้ส่วนกลับของระยะห่างระหว่างนิวเคลียสของอะตอมนั้นเป็นการจำลองเทอมของอันตรกิริยาระหว่างนิวเคลียสที่อยู่ใน 
Hamiltonian ของพลังงาน นิยามทางคณิตศาสตร์ของ Inverse Distance Matrix ($D$) อธิบายได้ตามสมการต่อไปนี้

\begin{equation}
    D_{ij} = \frac{1}{||r_{i} - r_{j}||}
\end{equation}

เมื่อเราคำนวณออกมาเป็นเมทริกซ์ขนาด $i \times j$ แล้ว เราจะพบว่าสมาชิกของเมทริกซ์ในแนวทแยง (Diagonal Elements) นั้นจะไม่มีความหมาย 
ดังนั้นเราจึงสนใจเฉพาะสมาชิกนอกแนวทแยง (Off-diagonal Elements)

%--------------------------
\subsection{Coulomb Matrix}
\idxth{ลักษณะเฉพาะ!เมทริกซ์คูลอมบ์}
\idxen{Representation!Coulomb Matrix}
%--------------------------

Coulomb Matrix (เมทริกซ์คูลอมบ์) เป็น Molecular Representation ที่ถูกเสนอครั้งแรกในปี ค.ศ. 2012 โดย Matthias Rupp 
และทีมวิจัย\cite{rupp2012} โดยได้ถูกนำมาใช้อย่างแพร่หลายในงานวิจัยทางด้าน ML นั่นก็เพราะว่าไม่มีความสิ้นเปลืองในการคำนวณและ%
ให้ความแม่นยำในการทำนายค่าพลังงานของโมเลกุลสูง ซึ่ง Coulomb Matrix นั้นถูกพัฒนาขึ้นมาโดยมีพื้นฐานมาจาก Inverse Distance Matrix 
ซึ่งเป็นการแก้ปัญหาที่พบใน Distance Matrix สองส่วนดังนี้

\begin{enumerate}
    \item มีการกำหนดเงื่อนไขในการคำนวณสมาชิกโดยกำหนดค่าของสมาชิกในแนวทแยง
    \item รวมประจุของอะตอมเข้าไปด้วย ซึ่งเป็น Parameter สำคัญในการพัฒนา Force Field สำหรับการจำลองพลวัตเชิงโมเลกุล (MD Simulation)
\end{enumerate}

สมการสำหรับการคำนวณสมาชิกของ Coulomb Matrix คือ

\begin{equation}
    \label{eq:cm}
    C_{ij} =
    \begin{cases}
     & 0.5 Z_i^{2.4} \text{ if } i = j \\ 
     & \frac{Z_i Z_j}{R_{ij}} \text{ if } i \neq j
    \end{cases}
\end{equation}

จากสมการที่ \ref{eq:cm} จะเห็นได้ว่าเราได้แบ่งเงื่อนไขในการคำนวณสมาชิกของ Coulomb Matrix ออกเป็นสองเงื่อนไข สำหรับกรณีคู่อะตอม%
เหมือนกันและต่างกัน โดยที่พลังงานศักย์เชิงไฟฟ้าสถิตย์ของอะตอมแต่ละคู่นั้นจะถูกเข้ามาด้วย (ผ่านเทอมของประจุ) นั่นก็คือสมาชิกนอกแนวทแยง%
จะแสดงถึงแรงผลักคูลอมบ์ระหว่างอะตอม ในขณะที่สมาชิกในแนวทแยงจะเป็นการเทียบเคียงค่าเลขอะตอมกับพลังงานของอะตอมในกรณีที่ไม่ได้มี%
อันตรกิริยากับอะตอมตัวอื่น

ถึงแม้ว่า Coulomb Matrix จะเป็น Representation ที่ไม่ขึ้นกับการเลื่อนตำแหน่งและการหมุนของโมเลกุล แต่ว่าก็ยังขึ้นอยู่กับการเปลี่ยนตำแหน่ง%
หรือการสลับที่กันของอะตอม เพื่อแก้ปัญหาดังกล่าว ได้มีนักวิจัยได้นำเสนอ Representation ตัวใหม่อีกหลายตัวที่เปรียบเสมือนเป็น Coulomb Matrix 
ที่ถูกปรับปรุงให้ดีขึ้น เช่น Permutation-Invariant Polynomials (PIP)\cite{braams2009}, Randomly Sorted Coulomb Matrices 
(RSCM)\cite{hansen2013}, Bag of Bonds (BoB)\cite{hansen2013}, และ Permutation Invariant Vectors (PIV)\cite{gallet2013} 
โดย Representation เหล่านี้ได้แก้ปัญหาเกี่ยวลำดับของอะตอม ทำให้ Representation ประเภทนี้มีประสิทธิภาพมากขึ้นและลด Bias ที่อาจจะเกิดขึ้นด้วย

ตัวอย่างโค้ดของการคำนวณ Coulomb Matrix โดยใช้ไลบรารี่ molml\cite{collins2018}

\begin{lstlisting}[style=MyPython]
>>> from molml.features import CoulombMatrix
>>> feat = CoulombMatrix()
>>> H2 = (
...         ['H', 'H'],
...         [
...             [0.0, 0.0, 0.0],
...             [1.0, 0.0, 0.0],
...         ]
... )
>>> HCN = (
...         ['H', 'C', 'N'],
...         [
...             [-1.0, 0.0, 0.0],
...             [ 0.0, 0.0, 0.0],
...             [ 1.0, 0.0, 0.0],
...         ]
... )
>>> feat.fit([H2, HCN])
CoulombMatrix(input_type='list', n_jobs=1, sort=False, eigen=False, drop_values=False, only_lower_triangle=False)
>>> feat.transform([H2])
array([[ 0.5,  1. ,  0. ,  1. ,  0.5,  0. ,  0. ,  0. ,  0. ]])
>>> feat.transform([H2, HCN])
array([[  0.5      ,   1.       ,   0.       ,   1.       ,   0.5      ,
        0.       ,   0.       ,   0.       ,   0.       ],
        [  0.5      ,   6.       ,   3.5      ,   6.       ,  36.8581052,
        42.       ,   3.5      ,  42.       ,  53.3587074]])
\end{lstlisting}

%--------------------------
\section{ลักษณะเฉพาะเชิงอิเล็กทรอนิกส์สำหรับอะตอม}
\idxth{ลักษณะเฉพาะ!เชิงอิเล็กทรอนิกส์สำหรับอะตอม}
\idxen{Representation!Electronic Descriptor}
%--------------------------

นอกเหนือจาก Representation ที่เรานำมาอธิบายโมเลกุลแบบทั้งโมเลกุล ยังมี Representation แบบอื่นที่มีความซับซ้อนที่ถูกพัฒนาขึ้นมาเพื่ออธิบาย
Environment ของโมเลกุลในระดับอะตอมแบบเฉพาะเจาะจง ซึ่ง Representation แบบนี้จะเป็นการรวมความสำคัญของกฎทางฟิสิกส์และเคมีแบบต่าง ๆ 
เข้ามาไว้ด้วยกัน จึงทำให้ Representation ประเภทนี้มีความสามารถในการที่จะอธิบายโครงสร้างเชิงอิเล็กทรอนิกส์ของโมเลกุลได้ดีมาก ๆ โดยเฉพาะ%
การทำนายคุณสมบัติในระดับอะตอม โดยในปัจจุบันก็ได้มีการพัฒนา Representation ประเภท Atom-wise อย่างมากมาย ดังนั้นผู้เขียนจะขออธิบาย%
เฉพาะ Representation ที่มีความโดดเด่นและเป็นที่นิยมเท่านั้น

%--------------------------
\subsection{Smooth Overlap of Atomic Positions}
\idxen{Representation!Smooth Overlap of Atomic Positions}
%--------------------------

Representation ที่เป็นประเภทเชิงอิเล็กทรอนิกส์สำหรับอะตอมอันแรกที่จะพูดถึงก็คือ Smooth Overlap of Atomic Positions (SOAP) 
ซึ่งเป็นตัวที่โด่งดังมากแล้วก็มีการนำมาใช้อย่างแพ่หลาย เรียกได้ว่านักวิจัยเคมีควอนตัมและปัญญาประดิษฐ์ต่างก็รู้จัก SOAP กันเป็นอย่างดี
โดยบทความงานวิจัยของ SOAP ได้ถูกตีพิมพ์ครั้งแรกในปี ค.ศ. 2013 ซึ่งไอเดียของ SOAP ก็คือจะเป็นการนำข้อมูลโครงสร้างของอะตอมมาเข้ารหัส 
(Encoding) ไว้ได้โดยได้รวมสภาพแวดล้อมทางเคมีโดยการใช้ความหนาแน่นเชิงอะตอมแบบเกาส์เซียน (Gaussian Smeared Atomic Density) 
ซึ่ง Atomic Density ที่ว่านี้ก็ถูกคำนวณมาจากฟังก์ชันพื้นฐานเชิงรัศมี (Radial Basis Function, $g_{n}(r)$) และฟังก์ชันฮาร์โมนิคเชิงทรงกลม 
(Real Spherical Harmonic Functions, $Y_{lm}(\theta, \phi)$)\cite{bartok2013,de2016}
โดย SOAP นั้นเหมาะสำหรับนำมาใช้ทำนายคุณสมบัติของโมเลกุลในระดับอะตอม (Local Properties) อย่างเช่นแรงเชิงอะตอม (Atomic Force) 
หรือ Chemical Shift

การคำนวณ SOAP นั้นจริง ๆ แล้วทำได้ผ่านการคำนวณ Kernel ของ Atomic Environment 2 อันเข้าด้วยกัน ($\mathcal{X}$ and $\mathcal{X}'$)
ซึ่งเขียนออกมาได้ในรูปของ Polynomial Kernel ($K^\mathrm{SOAP}$ ของ Parameter ที่ชื่อว่า Partial Power Spectra 
($\mathbf{p}$ และ $\mathbf{p}'$)\footnote{ผู้เขียนไม่แน่ใจว่าจะแปลเป็นภาษาไทยอย่างไรดี} 

โดยสมการที่เรานำมาใช้ในการคำนวณ SOAP นั้นคือ

\begin{equation}
    K^\mathrm{SOAP}(\mathbf{p}, \mathbf{p'}) = \left( \frac{\mathbf{p} \cdot \mathbf{p'}}{\sqrt{\mathbf{p} 
    \cdot \mathbf{p}~\mathbf{p'} \cdot \mathbf{p'}}}\right)^{\xi}
\end{equation}

\noindent โดยที่กำหนดให้ $\xi$ เป็นจำนวนเต็มบวกและสมาชิกของเวกเตอร์ $\mathbf{p}$ มีนิยามคือ 

\begin{equation}
    p^{Z_1 Z_2}_{n n' l} = \pi \sqrt{\frac{8}{2l+1}}\sum_m {c^{Z_1}_{n l m}}^{\dagger} c^{Z_2}_{n' l m}
\end{equation}

\noindent โดยที่ $n$ และ $n'$ เป็นดัชนีสำหรับ Radial Basis Function ซึ่งมีค่าได้สูงสุดถึง $n_{max}$, $l$ เป็นดีกรีเชิงมุม 
(Angular Degree) ของ Spherical Harmonics ซึ่งมีค่าได้สูงสุดถึง $l_{max}$, $m$ เป็นจำนวนเต็มที่สอดคล้องกับเงื่อนไขคือ $\abs{m} \leq l$, 
และ $Z_{1}$ และ $Z_{2}$ เป็นสปีชีส์เชิงอะตอม (Atomic Species) นากจากนี้ค่าสัมประสิทธิ์ $c^{Z}_{n'lm}$ และ ${c^{Z}_{nlm}}^{\dagger}$ 
ถูกนิยามให้เป็นผลคูณภายในของ Spherical Harmonic Functions กับความหนาแน่นเชิงอะตอมแบบเกาส์เซียน ($\rho^Z$) และคอนจูเกตเชิงซ้อน 
(Complex Conjugate) ตามลำดับ\cite{de2016} เนื่องจากว่ารายละเอียดในการพิสูจน์สมการ Kernel ของ SOAP นั้นมีความซับซ้อนมาก
ผู้อ่านสามารถศึกษาเพิ่มเติมได้ที่บทความต้นฉบับ ส่วนรายละเอียดในการคำนวณหรือการเขียนโปรแกรมสำหรับคำนวณ SOAP นั้นสามารถดูได้ที่
\url{https://singroup.github.io/dscribe/latest/tutorials/descriptors/soap.html}

%--------------------------
\subsection{Atom-centered Symmetry Functions}
\idxen{Representation!Atom-centered Symmetry Functions}
%--------------------------

Representation ลำดับถัดมาคือ Atom-centered Symmetry Functions (ACSF) เป็นวิธีที่ทำการสร้างผลลัพธ์หรือคำตอบจากฟังก์ชันหลายวัตถุ
(Many-body Functions) อีกทีหนึ่งเพื่อทำการประมาณค่า Electronic Environment รอบ ๆ อะตอมที่เราสนใจในโมเลกุล
ซึ่ง ACSF นี้ได้ถูกพัฒนาโดย J{\"o}rg Behler ซึ่งตีพิมพ์ในปี ค.ศ. 2011 โดยถูกออกแบบเพื่อนำมาใช้กับโมเดลประเภท Neuranl Network
\cite{behler2011}

ไอเดียของ ACSF ก็คือจะเป็นการแปลง (Transformation) พิกัดคาร์ทีเชียนให้เป็น Symmetry Function โดยจะมีการกำหนดฟังก์ชันสำหรับ 
Cutoff ขึ้นมาก่อน ดังนี้

\begin{equation}
    \label{eq:acsf_cutoff}
    f_{c}(R_{ij}) = 
    \begin{cases}
        \frac{1}{2}[\cos(\frac{\pi R_{ij}}{R_{c}}) + 1], & R_{ij} \le R_{c} \\
        0,                                             & R_{ij} \ge R_{c}
    \end{cases}
\end{equation}

\noindent โดยที่ $R_{ij}$ คือระยะห่างระหว่างอะตอม $i$ กับ $j$ และ $R_{c}$ คือค่า Cutoff

สำหรับ Symmetry Function ทั้งหมดที่เราสามารถนำมาคำนวณออกมาเป็น Descriptor ได้นั้นจะมีประเภทนั่นคือฟังก์ชันแบบสองวัตถุ
(Two-body Function) และฟังก์ชันแบบสามวัตถุ (Three-body Function) นั่นก็คือฟังก์ชันเชิงรัศมี (Radial Function) และฟังก์ชันเชิงมุม 
(Angular Function) ตามลำดับ โดยเรามาดูกันที่ Radial Function ก่อน ซึ่งจะมีด้วยกัน 3 แบบย่อย ดังนี้

\begin{equation}
    G^{1}_{i} = \sum_{j} f_{c}(R_{ij})
\end{equation}

\begin{equation}
    G^{2}_{i} = \sum_{j} e^{-\eta(R_{ij} - R_{s})^{2}} f_{c}(R_{ij})
\end{equation}

\begin{equation}
    G^{3}_{i} = \sum_{j} \cos(\kappa R_{ij}) f_{c}(R_{ij})
\end{equation}

\noindent ซึ่ง $G^{1}_{i}$ ก็คือฟังก์ชันผลรวมของ Cutoff Function (\ref{eq:acsf_cutoff}), $G^{2}_{i}$ คือผลรวม Gaussian Function
คูณด้วย Cutoff Function และ $G^{3}_{i}$ คือฟังก์ชัน Cosine ที่ถูกปรับการหน่วงโดยค่า Parameter $\kappa$ 

นอกจากนี้ยังมี Angular Function อีกสองอันย่อยด้วยกัน ดังนี้

\begin{align}
    G^{4}_{i} =~&2^{1 - \xi}\sum^{\text{all}}_{j,k \neq i} (1+\lambda \cos \theta_{ijk})^{\xi}
    \cdot e^{-\eta(R^{2}_{ij} + R^{2}_{ik} + R^{2}_{jk})} \nonumber \\
    & \cdot f_{c}(R_{ij}) \cdot f_{c}(R_{ik}) \cdot f_{c}(R_{jk})
\end{align}

\begin{align}
    G^{5}_{i} =~&2^{1 - \xi}\sum^{\text{all}}_{j,k \neq i} (1+\lambda \cos \theta_{ijk})^{\xi}
    \cdot e^{-\eta(R^{2}_{ij} + R^{2}_{ik})} \nonumber \\
    & \cdot f_{c}(R_{ij}) \cdot f_{c}(R_{ik}))
\end{align}

สำหรับการคำนวณหาแรง (Force) และเทนเซอร์แรงผลัก (Stress Tensor) สำหรับกรณีของ ACSF นั้นสามารถทำได้โดยใช้กฎลูกโซ่ (Chain Rule) 
ซึ่งต้องการทำพิสูจน์จากสมการของพลังงานที่เกิดขึ้นจากการคำนวณใน Neural Network โดยสำหรับค่าพลังงานย่อยต่อหนึ่งหน่วย Neuron นั้นมีนิยามตามนี้

\begin{equation}
    \label{eq:acsf_sub_ener}
    E_{\text{Neuron}} = f(w G + b) 
\end{equation}

\noindent โดยที่ $f$ คือฟังก์ชันกระตุ้น, $w$ คือ Weight Parameter, $b$ คือ Bias Parameter และ $G$ คืออินพุตของ Neuron นั้น ๆ 
ซึ่งก็คือ Symmetry Function ตามด้านบนที่ได้อธิบายไป โดยที่พลังงานรวมทั้งหมดของโมเลกุล (Total Energy, $E$) 
สามารถคำนวณได้จากผลรวมของพลังงานย่อย ๆ ที่เกิดขึ้นจากแต่ละอะตอม (\ref{eq:acsf_sub_ener}) ซึ่งมีสมการง่าย ๆ ดังนี้

\begin{equation}
    E = \sum_{i} E_{i}
\end{equation}

นอกจากนี้ยังมี Representation อื่น ๆ ที่คล้ายกับ ACSF นั่นคือถูกพัฒนาขึ้นมาด้วยไอเดีย Symmetry Function เหมือนกัน เช่น 
Spectrum of London and Axilrod-Teller-Muto (SLATM) ซึ่งถูกใช้อย่างแพร่พลายเหมือนกันแต่จะนิยมใช้กับ KRR มากกว่า\cite{faber2018} 
แล้วก็ยังมีการใช้ Polynomial functions ของส่วนกลับของระยะห่างระหว่างอะตอมด้วย\cite{kwac2019,musil2021}

%--------------------------
\subsection{Gaussian-type Orbital-based Density Vectors}
\idxen{Representation!Gaussian-type Orbital-based Density Vectors}
%--------------------------

Gaussian-type Orbital-based Density Vector (เรียกสั้น ๆ ว่า GTB-based Density Vector) เป็น Representation 
อีกอันหนึ่งที่ใช้หลักการของ Molecular/Atomic Orbitals ซึ่งถูกพัฒนาขึ้นมาเพื่อให้เป็นอีกทางเลือกหนึ่งนอกเหนือจาก ACSF และ 
Symmstric Polynomial Function\cite{kwac2021} โดยสมการที่ใช้คำนวณ GTO-based Density Vector คือ

\begin{equation}
    \rho^{i}_{L,\alpha,r_{s}} = \sum^{l_{x}+l_{y}+l_{z} = L}_{l_{x},l_{y},l_{z}} 
    \frac{L!}{l_{x}!l_{y}!l_{z}!} \left ( \sum^{n_{type}}_{t=1} c_{t} \sum^{N^{t}_{atom}}_{j=1} 
    \phi^{\alpha,r_{s}}_{l_{x}l_{y}l_{z}} (\boldsymbol{r}_{ij}) \right )
\end{equation}

\noindent โดยกำหนดให้ $l_{x}+l_{y}+l_{z} = L$ เป็นเลข Angular Momentum ของออร์บิทัล, $n_{type}$ ชนิดของอะตอมในโมเลกุลที่ศึกษา, 
$c_{t}$ เป็นค่าถ่วงน้ำหนักที่ขึ้นกับชนิดของอะตอม (The Type-dependent Weight), $N^{t}_{atom}$ คือจำนวนอะตอมของชนิดนั้น ๆ
และ $\phi^{\alpha,r_{s}}_{l_{x}l_{y}l_{z}} (r_{ij})$ เป็นออร์บิทัลแบบเกาส์เซียนของแต่ละอะตอม นอกจากนี้ยังมีการกำหนด 
Parameter เพิ่มเติมคือ $\alpha$ และ $r_{s}$ ซึ่งเป็นตัวกำหนดฟังก์ชันออร์บิทัลของ Radial Distribution

\begin{equation}
    \phi^{\alpha,r_{s}}_{l_{x}l_{y}l_{z}} (\boldsymbol{r}_{ij}) = x^{l_{x}}y^{l_{y}}z^{l_{z}} e^{-\alpha 
    |r-r_{s}|^{2}}
\end{equation}

\noindent โดยกำหนดให้ $\boldsymbol{r}_{ij} = (x,y,z)$ แสดงถึงเวกเตอร์จากอะตอม $i$ ไปยังอะตอม $j$ และ $r$ 
เป็นขนาด (Magnitude) ของ $\boldsymbol{r}_{ij}$ โดยทั่วไปแล้วเรามักจะกำหนดให้ค่า $L=0,1$ สำหรับการสร้าง Density Vector ด้วย GTO
สำหรับโมเลกุลขนาดเล็ก เช่น โมเลกุลเคมีอินทรีย์ที่ประกอบไปด้วยอะตอมขนาดเล็ก เช่น คาร์บอน, ไฮโดรเจน, ออกซิเจน, และไนโตรเจน\cite{kwac2021}
