% LaTeX source for ``การเรียนรู้ของเครื่องสำหรับเคมีควอนตัม (Machine Learning for Quantum Chemistry)''
% Copyright (c) 2022 รังสิมันต์ เกษแก้ว (Rangsiman Ketkaew).

% License: Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)
% https://creativecommons.org/licenses/by-nc-nd/4.0/

\chapter{การเรียนรู้แบบไม่มีผู้สอน}
\label{ch:unsup_ml}

การเรียนรู้แบบไม่มีผู้สอน (Unsupervised Learning) เป็นเทคนิคที่อาจจะเรียกว่าได้ตรงข้ามกับ supervised learning ก็ได้
เพราะว่าเทคนิคประเภทนี้จะเป็นการเทรนโมเดลแบบไม่มีการบอกคำตอบหรือเอาต์พุตให้โมเดลได้รับรู้ ดังนั้นสิ่งที่โมเดลจะต้องพยายามทำออกมา
ให้ได้คือเป็นการเรียนรู้หาความสัมพันธ์ (Relation) หรือ สหสัมพันธ์ (Correlation) ระหว่างข้อมูลแต่ละตัวภายในชุดข้อมูล (Input) 
ที่เราสนใจได้ได้ป้อนเข้าไป

%--------------------------
\section{Weighted Pair Group Method with Arithmetic Mean}
\idxen{Weighted Pair Group Method with Arithmetic Mean}
%--------------------------

Weighted Pair Group Method with Arithmetic Mean (WPGMA) เป็นเทคนิคการจัดกลุ่ม (Clustering) แบบ Hierarchical 
โดยถูกพัฒนาขึ้นมาโดยใช้ Pairwise Similarity Matrix\cite{sokal1958} 

%--------------------------
\section{Principal Component Analysis}
\idxboth{การวิเคราะห์องค์ประกอบหลัก}{Principal Component Analysis}
%--------------------------

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{fig/pca.png}
    \caption{Principal Component Analysis ของข้อมูลที่มีการกระจายตัวแบบเกาส์เซียนหลายตัวแปร (Multivariate Gaussian
    Distribution) เวกเตอร์ที่แสดงนั้นเป็น Eigenvector ของ Covariance Matrix ที่มีการปรับขนาด (Scaled) โดยใช้ค่ายกกำลังสองของ 
    Eigenvalue และมีการปรับตำแหน่งโดยใช้ค่าเฉลี่ย}
    \label{fig:pca}
\end{figure}

การวิเคราะห์องค์ประกอบหลัก (Principal Component Analysis หรือ PCA) เป็นวิธีทางสถิติที่ถูกเอามาใช้เพื่อรับมือกับข้อมูลที่มี
จำวนหลายมิติหรือมีหลายตัวแปร โดย PCA สามารถหาความสัมพันธ์ของตัวแปรเหล่านั้นโดยทำการลดขนาดของมิติโดยสร้างชุดข้อมูลใหม่ที่อาศัย
แกนอ้างอิงจากชุดข้อมูลเดิม ซึ่งจำนวนมิติที่ถูกลดลงนั้นก็มีจำนวนมิติเพียง 2 หรือ 3 มิติเท่านั้น ซึ่งทำให้ง่ายต่อการตีความและวิเคราะห์ข้อมูล เช่น
การจัดกลุ่มชุดข้อมูลโดยจำแนกตาม Feature ซึ่ง Feature แต่ละคู่จะมีคุณสมบัติ Orthogonality หรือตั้งฉากกันนั่นเอง ทำให้เราสามารถแสดง
ผลลัพธ์ของ PCA ออกมาได้ในปริภูมิทั่วไป

%--------------------------
\section{การเข้ารหัสแบบอัตโนมัติ}
\idxboth{การเข้ารหัสแบบอัตโนมัติ}{Autoencoder}
%--------------------------

การเข้ารหัสแบบอัตโนมัติหรือ Autoencoder

\begin{center}
\begin{tikzpicture}[x=2.1cm,y=1.2cm]
    % \large
    \message{^^JNeural network without arrows}
    \readlist\Nnod{6,5,4,3,4,5,6} % array of number of nodes per layer
    
    % TRAPEZIA
    \node[above,align=center,myorange!60!black] at (3,2.4) {Encoder};
    \node[above,align=center,myblue!60!black] at (5,2.4) {Decoder};
    \draw[myorange!40,fill=myorange,fill opacity=0.02,rounded corners=2]
    (1.6,-2.7) --++ (0,5.4) --++ (2.8,-1.2) --++ (0,-3) -- cycle;
    \draw[myblue!40,fill=myblue,fill opacity=0.02,rounded corners=2]
    (6.4,-2.7) --++ (0,5.4) --++ (-2.8,-1.2) --++ (0,-3) -- cycle;
    
    \message{^^J  Layer}
    \foreachitem \N \in \Nnod{ % loop over layers
    \def\lay{\Ncnt} % alias of index of current layer
    \pgfmathsetmacro\prev{int(\Ncnt-1)} % number of previous layer
    \message{\lay,}
    \foreach \i [evaluate={\y=\N/2-\i+0.5; \x=\lay; \n=\nstyle;}] in {1,...,\N}{ % loop over nodes
    
    % NODES
    \node[node \n,outer sep=0.6] (N\lay-\i) at (\x,\y) {};
    
    % CONNECTIONS
    \ifnum\lay>1 % connect to previous layer
    \foreach \j in {1,...,\Nnod[\prev]}{ % loop over nodes in previous layer
    \draw[connect,white,line width=1.2] (N\prev-\j) -- (N\lay-\i);
    \draw[connect] (N\prev-\j) -- (N\lay-\i);
    %\draw[connect] (N\prev-\j.0) -- (N\lay-\i.180); % connect to left
    }
    \fi % else: nothing to connect first layer
    
    }
    }
    
    % LABELS
    \node[above=2,align=center,mygreen!60!black] at (N1-1.90) {Input};
    \node[above=2,align=center,myred!60!black] at (N\Nnodlen-1.90) {Output};
    
\end{tikzpicture}
\end{center}

ตัวเข้ารหัสแบบอัตโนมัติ (Autoencoder หรือ AE) เป็นอัลกอริทึม Unsupervised Learning แบบหนึ่งที่ใช้โมเดล ANN โดยมีรูปแบบของ 
Network ที่เฉพาะตัวนั่นก็คือจะทำการลดมิติของข้อมูลโดยทำการบีบอัดข้อมูลหรือเข้ารหัส (Encoding) และทำการถอดรหัส (Decoding) 
ออกมาเป็นข้อมูลเดิม\cite{ballard1987} ตัวโมเดล AE มีความพิเศษคือจะมีลักษณะของความสมมาตร นอกจากนี้ยังมีความแตกต่างจาก PCA 
นั่นก็คือสามารถบีบอัดหรือลดจำนวนมิติของข้อมูลแบบไม่เป็นเส้นตรงได้ (Nonlinear) ได้ด้วยการใช้ฟังก์ชันกระตุ้นแบบ Nonlinear

%--------------------------
\section{การแบ่งกลุ่มข้อมูลแบบเคมีน}
\idxen{K-means Clustering}
%--------------------------

การแบ่งกลุ่มข้อมูลแบบเคมีน (K-means Clustering) เป็นหนึ่งในวิธีการแบ่งเวกเตอร์ซึ่งจะเป็นการแบ่งชุดข้อมูลที่มี n ข้อมูลออกเป็น k กลุ่ม
ซึ่งเทคนิคนี้ได้ถูกใช้มาอย่างยาวนานตั้งแต่ในช่วงยุคเริ่มต้นของการทำ Data Mining\cite{macqueen1967}

\begin{figure}[H]
    \centering
    \subfloat[เลือกค่าเฉลี่ย\label{fig:k_means_step1}]{\includegraphics[width=0.4\linewidth]{fig/k-means-step1.png}}
    \hspace{1em}
    \subfloat[สร้างคลัสเตอร์ k กลุ่ม\label{fig:k_means_step2}]{\includegraphics[width=0.4\linewidth]{fig/k-means-step2.png}}
    \\
    \vspace{1em}
    \subfloat[คำนวณค่าเฉลี่ยใหม่\label{fig:k_means_step3}]{\includegraphics[width=0.4\linewidth]{fig/k-means-step3.png}}
    \hspace{1em}
    \subfloat[ทำซ้ำจนกระทั่งค่ากลางลู่เข้า\label{fig:k_means_step4}]{\includegraphics[width=0.4\linewidth]{fig/k-means-step4.png}}
    \caption{ขั้นตอนการทำ K-means Clustering (เครดิตภาพ: \url{https://en.wikipedia.org/wiki/K-means_clustering})}
    \label{fig:k_means}
\end{figure}
 
ภาพที่ \ref{fig:k_means} แสดงอัลกอริทึมของ K-means Clustering ที่มี 4 ขั้นตอน โดยขั้นตอนที่หนึ่งจะเป็นเลือกค่าเฉลี่ยเริ่มต้น k 
(ในกรณีนี้ k=3) แบบสุ่มจากโดเมนข้อมูล ขั้นตอนที่สองเป็นการสร้างคลัสเตอร์ k กลุ่มรอบ ๆ ค่าเฉลี่ยทีได้กำหนดไว้โดยการเชื่อมโยงทุกข้อมูล%
การสังเกตด้วยค่าเฉลี่ยที่ใกล้ที่สุด (สังเกตระยะห่างระหว่างจุดวงกลมในแต่ละคลัสเตอร์ไปจนถึงเส้นแบ่ง) เส้นแบ่งในที่นี้แสดงให้เห็นแผนภาพของโวโรนอย 
(Voronoi Diagram) ที่สร้างขึ้นจากค่าเฉลี่ย ขั้นตอนที่สามคือคำนวณจุดศูนย์กลางหรือจุดเซนทรอยด์ (Centroid) ของโวโรนอยของแต่ละคลัสเตอร์%
และทำการกำหนดเป็นค่าเฉลี่ยค่าใหม่ ขั้นตอนที่สี่จะเป็นการทำสามขั้นตอนแรกซ้ำ ซึ่งจะทำซ้ำไปเรื่อย ๆ จนกว่าค่ากลางของแต่ละคลัสเตอร์จะไม่เปลี่ยนแปลง
โดยเมื่อค่ากลางลู่เข้าแล้ว เราจะได้ฟังก์ชันที่มีเส้นแบ่งสำหรับการนำไปจัดคลัสเตอร์ของข้อมูล Test Set ต่อไป
